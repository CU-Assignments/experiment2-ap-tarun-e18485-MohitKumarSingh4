1.	Aim: Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. Each input has exactly one solution, and you cannot use the same element twice.
2.	Algorithm:
•	Initialize an empty hash map (dict).
•	Iterate through the nums array:
•	For each element num, calculate the complement: complement = target - num.
•	Check if the complement exists in the hash map:
	If it does, return the indices of the complement and the current number.
	If it doesn't, add the current number and its index to the hash map.
•	Return the indices of the two numbers that add up to the target.

3.	Implementation/Code:
#include <iostream>
#include <unordered_map> 
#include <vector>
using namespace std;
vector<int> twoSum(vector<int>& nums, int target)
{
unordered_map<int, int> seen;
for (int i = 0; i < nums.size(); i++) { 
int complement = target - nums[i];
if (seen.find(complement) != seen.end()) { 
return {seen[complement], i};
}
seen[nums[i]] = i;
}
return {};
}
int main() {
vector<int> nums = {2, 7, 11, 15}; 
int target = 9;
vector<int> result = twoSum(nums, target);
 
cout << "Indexes: [" << result[0] << ", " << result[1] << "]" << endl; return 0;
}

4.	Output:
Indexes: [0,1]

5.	Learning Outcome:
•	Learn how to use hash maps to efficiently solve problems that require quick lookups for complements or matches in arrays.
•	Learn to optimize brute force approaches (O(n²)) into linear time solutions (O(n)) by leveraging hash maps for complement checks.
•	Develop the ability to break down a problem into logical steps, such as finding a complement and storing indices for reference.
•	Gain insight into how data structures like arrays and hash maps can work together to solve real-world problems effectively

6.	Time Complexity: O ( n ), where n is the number of elements in the nums array. This is because we only iterate through the array once.
7.	Space Complexity: O ( n ), since we store each number and its index in the hash map.
